import { type editor, languages, Position, Range } from "monaco-editor";

const GQLKeywords = [
  "ACYCLIC",
  "AND",
  "ANY",
  "AVG",
  "ALL",
  "AS",
  "ASC",
  "BY",
  "BOOL",
  "COUNT",
  "CREATE",
  "DESC",
  "DISTINCT",
  "EDGE",
  "FROM",
  "INSERT",
  "INTEGER",
  "IS",
  "FILTER",
  "FLOAT",
  "GROUP",
  "LABELS",
  "LABEL",
  "LIMIT",
  "MATCH",
  "MAX",
  "MIN",
  "OFFSET",
  "OPTIONAL",
  "ORDER",
  "OR",
  "OUTGOING",
  "PROPERTIES",
  "PROPERTY",
  "NOT",
  "SHORTEST",
  "SIMPLE",
  "RETURN",
  "SET",
  "SUM",
  "STORE",
  "STRING",
  "TENSOR",
  "TENSOR_DISTANCE",
  "TRAIL",
  "WALK",
  "WHERE",
];

const MQLKeywords = [
  // function
  "ASC",
  "AVG",
  "COSINE_DISTANCE",
  "COSINE_SIMILARITY",
  "COUNT",
  "DESC",
  "EUCLIDEAN_DISTANCE",
  "MAX",
  "MIN",
  "REGEX",
  // procedure (not in grammar)
  "HNSW_TOP_K",
  "HNSW_SCAN",
  "TEXT_SEARCH",
  // keyword
  "ACYCLIC",
  "ALL",
  "AND",
  "ANY",
  "AS",
  "BOOL",
  "BY",
  "CALL",
  "CREATE",
  "DELETE",
  "DESCRIBE",
  "DIMENSIONS",
  "DISTINCT",
  "EDGE",
  "FLOAT",
  "FROM",
  "GROUP",
  "GROUPS",
  "IDENTITY",
  "INCOMING",
  "INDEX",
  "INSERT",
  "INTEGER",
  "INTO",
  "IS",
  "LABEL",
  "LABELS",
  "LET",
  "LIMIT",
  "MATCH",
  "NOT",
  "OBJECTS",
  "OFFSET",
  "OPTIONAL",
  "OR",
  "ORDER",
  "OUTGOING",
  "PREFIX",
  "PROPERTIES",
  "PROPERTY",
  "RETURN",
  "SHORTEST",
  "SHOW",
  "SIMPLE",
  "STRING",
  "SUM",
  "TRAILS",
  "VALUES",
  "WALKS",
  "WHERE",
  "WITH",
  "YIELD",
];

const SPARQLKeywords = [
  // function
  "AND",
  "OR",
  // keyword
  "ACYCLIC",
  "ALL",
  "ANY",
  "AS",
  "ASC",
  "ASK",
  "BASE",
  "BINDINGS",
  "BY",
  "CONSTRUCT",
  "DESC",
  "DESCRIBE",
  "DISTINCT",
  "FILTER",
  "FROM",
  "GRAPH",
  "GROUP",
  "HAVING",
  "INDEX",
  "LIMIT",
  "MINUS",
  "NAMED",
  "OFFSET",
  "OPTIONAL",
  "ORDEDR",
  "PREFIX",
  "REDUCED",
  "SELECT",
  "SERVICE",
  "SHORTEST",
  "SHOW",
  "SILENT",
  "SIMPLE",
  "UNDEF",
  "UNION",
  "VALUES",
  "WALKS",
  "WHERE",
  // function
  "ABS",
  "AVG",
  "BIND",
  "BNODE",
  "BOUND",
  "CEIL",
  "COALESCE",
  "CONCAT",
  "CONTAINS",
  "COUNT",
  "DATATYPE",
  "DAY",
  "ENCODE_FOR_URI",
  "EXISTS",
  "FLOOR",
  "GROUP_CONCAT",
  "HOURS",
  "IF",
  "IN",
  "IRI",
  "ISBLANK",
  "ISIRI",
  "ISLITERAL",
  "ISNUMERIC",
  "ISURI",
  "LANG",
  "LANGMATCHES",
  "LCASE",
  "MAX",
  "MD5",
  "MIN",
  "MINUTES",
  "MONTH",
  "NOT",
  "NOW",
  "RAND",
  "REGEX",
  "REPLACE",
  "ROUND",
  "SAMETERM",
  "SAMPLE",
  "SECONDS",
  "SEPARATOR",
  "SHA1",
  "SHA256",
  "SHA384",
  "SHA512",
  "STR",
  "STRAFTER",
  "STRBEFORE",
  "STRDT",
  "STRENDS",
  "STRLANG",
  "STRLEN",
  "STRSTARTS",
  "STRUUID",
  "SUBSTR",
  "SUM",
  "TIMEZONE",
  "TZ",
  "UCASE",
  "URI",
  "UUID",
  "YEAR",
];

export class MDBCompletionProvider implements languages.CompletionItemProvider {
  private _keywords: string[];

  constructor(languageId: string) {
    switch (languageId) {
      case "mdb-gql": {
        this._keywords = GQLKeywords;
        break;
      }
      case "mdb-mql": {
        this._keywords = MQLKeywords;
        break;
      }
      case "mdb-sparql": {
        this._keywords = SPARQLKeywords;
        break;
      }
      default:
        throw new Error(`Unhandled languageId: ${languageId}`);
    }
  }

  provideCompletionItems(
    model: editor.ITextModel,
    position: Position,
  ): languages.ProviderResult<languages.CompletionList> {
    const word = model.getWordAtPosition(position);
    if (!word) return { suggestions: [] };

    const range = new Range(
      position.lineNumber,
      word.startColumn,
      position.lineNumber,
      word.endColumn,
    );

    return {
      suggestions: this._keywords.map((kw: string) => ({
        label: kw,
        kind: languages.CompletionItemKind.Keyword,
        insertText: kw,
        range,
      })),
    };
  }
}
