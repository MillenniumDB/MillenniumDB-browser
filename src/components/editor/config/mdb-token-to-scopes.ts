/*
 * In this file we define the tokenization mapping from ANTLR4 to monaco editor.
 * In the future we could enhance this by using the context of the query.
 *
 */

import GQLLexer from "@/grammar/gql/GQLLexer";
import MQL_Lexer from "@/grammar/mql/MQL_Lexer";
import SparqlQueryLexer from "@/grammar/sparql/SparqlQueryLexer";
import type { Token } from "antlr4";

export type TokenToScopes = (token: Token) => string;

const GQLTokenToScopes: TokenToScopes = (token: Token) => {
  switch (token.type) {
    case GQLLexer.COMMENT:
    case GQLLexer.Comment:
    case GQLLexer.SIMPLE_COMMENT:
    case GQLLexer.SIMPLE_COMMENT_INTRODUCER:
    case GQLLexer.SIMPLE_COMMENT_CHARACTER:
    case GQLLexer.BRACKETED_COMMENT:
    case GQLLexer.BRACKETED_COMMENT_INTRODUCER:
    case GQLLexer.BRACKETED_COMMENT_TERMINATOR:
    case GQLLexer.BRACKETED_COMMENT_CONTENTS:
      return "comment";
    case GQLLexer.VARIABLE:
    case GQLLexer.REGULAR_IDENTIFIER:
      return "variable";
    case GQLLexer.AMPERSAND:
    case GQLLexer.ASTERISK:
    case GQLLexer.CIRCUMFLEX:
    case GQLLexer.COLON:
    case GQLLexer.COMMA:
    case GQLLexer.DOLLAR_SIGN:
    case GQLLexer.EQUALS_OPERATOR:
    case GQLLexer.EXCLAMATION_MARK:
    case GQLLexer.MINUS_SIGN:
    case GQLLexer.MULTISET_ALTERNATION_OPERATOR:
    case GQLLexer.PERCENT:
    case GQLLexer.PERIOD:
    case GQLLexer.PLUS_SIGN:
    case GQLLexer.QUESTION_MARK:
    case GQLLexer.REVERSE_SOLIDUS:
    case GQLLexer.SOLIDUS:
    case GQLLexer.TILDE:
    case GQLLexer.VERTICAL_BAR:
    case GQLLexer.ABS:
      return "operator";
    case GQLLexer.RIGHT_ANGLE_BRACKET:
    case GQLLexer.LEFT_BRACE:
    case GQLLexer.LEFT_BRACKET:
    case GQLLexer.LEFT_PAREN:
    case GQLLexer.LEFT_ANGLE_BRACKET:
    case GQLLexer.RIGHT_BRACE:
    case GQLLexer.RIGHT_BRACKET:
    case GQLLexer.RIGHT_PAREN:
    case GQLLexer.SEMICOLON:
    case GQLLexer.UNDERSCORE:
      return "function";
    case GQLLexer.UNSIGNED_DECIMAL_INTEGER:
    case GQLLexer.UNSIGNED_HEXADECIMAL_INTEGER:
    case GQLLexer.UNSIGNED_OCTAL_INTEGER:
    case GQLLexer.UNSIGNED_BINARY_INTEGER:
    case GQLLexer.UNSIGNED_DECIMAL_IN_SCIENTIFIC_NOTATION:
    case GQLLexer.UNSIGNED_DECIMAL_IN_COMMON_NOTATION:
      return "number";
    case GQLLexer.ACYCLIC:
    case GQLLexer.AND:
    case GQLLexer.ANY:
    case GQLLexer.AVG:
    case GQLLexer.ALL:
    case GQLLexer.ASC:
    case GQLLexer.AS:
    case GQLLexer.BY:
    case GQLLexer.BOOL:
    case GQLLexer.COUNT:
    case GQLLexer.DESCRIBE:
    case GQLLexer.DESC:
    case GQLLexer.DISTINCT:
    case GQLLexer.INSERT:
    case GQLLexer.IS:
    case GQLLexer.IN:
    case GQLLexer.FILTER:
    case GQLLexer.FLOAT:
    case GQLLexer.FOR:
    case GQLLexer.GROUP:
    case GQLLexer.LABELS:
    case GQLLexer.LABEL:
    case GQLLexer.LET:
    case GQLLexer.LIMIT:
    case GQLLexer.MAX:
    case GQLLexer.MATCH:
    case GQLLexer.MIN:
    case GQLLexer.OFFSET:
    case GQLLexer.OPTIONAL:
    case GQLLexer.ORDER:
    case GQLLexer.OR:
    case GQLLexer.PATH_LENGTH:
    case GQLLexer.PROPERTY:
    case GQLLexer.NOT:
    case GQLLexer.NULLS:
    case GQLLexer.SHORTEST:
    case GQLLexer.SIMPLE:
    case GQLLexer.RETURN:
    case GQLLexer.SET:
    case GQLLexer.SUM:
    case GQLLexer.SKIP:
    case GQLLexer.TRAIL:
    case GQLLexer.WHERE:
      return "keyword";
    case GQLLexer.STRING:
    case GQLLexer.DOUBLE_QUOTED_STRING_LITERAL:
    case GQLLexer.SINGLE_QUOTED_STRING_LITERAL:
    case GQLLexer.ACCENT_QUOTED_STRING_LITERAL:
      return "string";
    case GQLLexer.NULL:
      return "null";
    default:
      return "";
  }
};

const MQLTokenToScopes: TokenToScopes = (token: Token) => {
  switch (token.type) {
    case MQL_Lexer.SINGLE_LINE_COMMENT:
      return "comment";
    case MQL_Lexer.STRING:
      return "string";
    case MQL_Lexer.UNSIGNED_INTEGER:
    case MQL_Lexer.UNSIGNED_FLOAT:
      return "number";
    case MQL_Lexer.VARIABLE:
    case MQL_Lexer.TYPE_VAR:
    case MQL_Lexer.ANON_ID:
    case MQL_Lexer.EDGE_ID:
      return "variable";
    case MQL_Lexer.TYPE:
      return "type";
    case MQL_Lexer.K_FALSE:
    case MQL_Lexer.K_TRUE:
      return "boolean";
    case MQL_Lexer.LEQ:
    case MQL_Lexer.GEQ:
    case MQL_Lexer.EQ:
    case MQL_Lexer.NEQ:
    case MQL_Lexer.LT:
    case MQL_Lexer.GT:
    case MQL_Lexer.SINGLE_EQ:
    case MQL_Lexer.PATH_SEQUENCE:
    case MQL_Lexer.PATH_ALTERNATIVE:
    case MQL_Lexer.PATH_NEGATION:
    case MQL_Lexer.STAR:
    case MQL_Lexer.PERCENT:
    case MQL_Lexer.QUESTION_MARK:
    case MQL_Lexer.PLUS:
    case MQL_Lexer.MINUS:
      return "operator";
    case MQL_Lexer.K_ASC:
    case MQL_Lexer.K_AVG:
    case MQL_Lexer.K_COSINE_DISTANCE:
    case MQL_Lexer.K_COSINE_SIMILARITY:
    case MQL_Lexer.K_COUNT:
    case MQL_Lexer.K_DESC:
    case MQL_Lexer.K_EUCLIDEAN_DISTANCE:
    case MQL_Lexer.K_MAX:
    case MQL_Lexer.K_MIN:
    case MQL_Lexer.K_REGEX:
      return "function";
    case MQL_Lexer.K_ACYCLIC:
    case MQL_Lexer.K_ALL:
    case MQL_Lexer.K_AND:
    case MQL_Lexer.K_ANY:
    case MQL_Lexer.K_AS:
    case MQL_Lexer.K_BOOL:
    case MQL_Lexer.K_BY:
    case MQL_Lexer.K_CALL: // TODO: highlight procedures
    case MQL_Lexer.K_CREATE:
    case MQL_Lexer.K_DELETE:
    case MQL_Lexer.K_DESCRIBE:
    case MQL_Lexer.K_DIMENSIONS:
    case MQL_Lexer.K_DISTINCT:
    case MQL_Lexer.K_EDGE:
    case MQL_Lexer.K_FLOAT:
    case MQL_Lexer.K_FROM:
    case MQL_Lexer.K_GROUP:
    case MQL_Lexer.K_GROUPS:
    case MQL_Lexer.K_IDENTITY:
    case MQL_Lexer.K_INCOMING:
    case MQL_Lexer.K_INDEX:
    case MQL_Lexer.K_INSERT:
    case MQL_Lexer.K_INTEGER:
    case MQL_Lexer.K_INTO:
    case MQL_Lexer.K_IS:
    case MQL_Lexer.K_LABEL:
    case MQL_Lexer.K_LABELS:
    case MQL_Lexer.K_LET:
    case MQL_Lexer.K_LIMIT:
    case MQL_Lexer.K_MATCH:
    case MQL_Lexer.K_NOT:
    case MQL_Lexer.K_OBJECTS:
    case MQL_Lexer.K_OFFSET:
    case MQL_Lexer.K_OPTIONAL:
    case MQL_Lexer.K_OR:
    case MQL_Lexer.K_ORDER:
    case MQL_Lexer.K_OUTGOING:
    case MQL_Lexer.K_PREFIX:
    case MQL_Lexer.K_PROPERTIES:
    case MQL_Lexer.K_PROPERTY:
    case MQL_Lexer.K_RETURN:
    case MQL_Lexer.K_SHORTEST:
    case MQL_Lexer.K_SHOW:
    case MQL_Lexer.K_SIMPLE:
    case MQL_Lexer.K_STRING:
    case MQL_Lexer.K_SUM:
    case MQL_Lexer.K_TEXT_SEARCH:
    case MQL_Lexer.K_TRAILS:
    case MQL_Lexer.K_VALUES:
    case MQL_Lexer.K_WALKS:
    case MQL_Lexer.K_WHERE:
    case MQL_Lexer.K_WITH:
    case MQL_Lexer.K_YIELD:
      return "keyword";
    case MQL_Lexer.K_NULL:
      return "null";
    default:
      return "";
  }
};

const SPARQLTokenToScopes: TokenToScopes = (token: Token) => {
  switch (token.type) {
    case SparqlQueryLexer.COMMENT:
      return "comment";
    case SparqlQueryLexer.PNAME_NS:
      return "iri-prefix";
    case SparqlQueryLexer.PNAME_LN:
    case SparqlQueryLexer.BLANK_NODE_LABEL:
      return "iri";
    case SparqlQueryLexer.IRIREF:
    case SparqlQueryLexer.A:
      return "iri";
    case SparqlQueryLexer.LANGTAG:
      return "langtag";
    case SparqlQueryLexer.K_FALSE:
    case SparqlQueryLexer.K_TRUE:
      return "boolean";
    case SparqlQueryLexer.VAR1:
    case SparqlQueryLexer.VAR2:
      return "variable";
    case SparqlQueryLexer.STRING_LITERAL1:
    case SparqlQueryLexer.STRING_LITERAL2:
    case SparqlQueryLexer.STRING_LITERAL_LONG1:
    case SparqlQueryLexer.STRING_LITERAL_LONG2:
      return "string";
    case SparqlQueryLexer.DECIMAL_NEGATIVE:
    case SparqlQueryLexer.DECIMAL_POSITIVE:
    case SparqlQueryLexer.DECIMAL:
    case SparqlQueryLexer.DOUBLE_NEGATIVE:
    case SparqlQueryLexer.DOUBLE_POSITIVE:
    case SparqlQueryLexer.DOUBLE:
    case SparqlQueryLexer.INTEGER_NEGATIVE:
    case SparqlQueryLexer.INTEGER_POSITIVE:
    case SparqlQueryLexer.INTEGER:
      return "number";
    case SparqlQueryLexer.FALSE:
    case SparqlQueryLexer.TRUE:
      return "boolean";
    case SparqlQueryLexer.AND:
    case SparqlQueryLexer.ASTERISK:
    case SparqlQueryLexer.DIVIDE:
    case SparqlQueryLexer.EQUAL:
    case SparqlQueryLexer.GREATER_EQUAL:
    case SparqlQueryLexer.GREATER:
    case SparqlQueryLexer.INVERSE:
    case SparqlQueryLexer.LESS_EQUAL:
    case SparqlQueryLexer.LESS:
    case SparqlQueryLexer.MINUS_SIGN:
    case SparqlQueryLexer.NEGATION:
    case SparqlQueryLexer.NOT_EQUAL:
    case SparqlQueryLexer.OR:
    case SparqlQueryLexer.PIPE:
    case SparqlQueryLexer.PLUS_SIGN:
    case SparqlQueryLexer.QUESTION_MARK:
    case SparqlQueryLexer.REFERENCE:
      return "operator";
    case SparqlQueryLexer.ACYCLIC:
    case SparqlQueryLexer.ALL:
    case SparqlQueryLexer.ANY:
    case SparqlQueryLexer.AS:
    case SparqlQueryLexer.ASC:
    case SparqlQueryLexer.ASK:
    case SparqlQueryLexer.BASE:
    case SparqlQueryLexer.BINDINGS:
    case SparqlQueryLexer.BY:
    case SparqlQueryLexer.CONSTRUCT:
    case SparqlQueryLexer.DESC:
    case SparqlQueryLexer.DESCRIBE:
    case SparqlQueryLexer.DISTINCT:
    case SparqlQueryLexer.FILTER:
    case SparqlQueryLexer.FROM:
    case SparqlQueryLexer.GRAPH:
    case SparqlQueryLexer.GROUP:
    case SparqlQueryLexer.HAVING:
    case SparqlQueryLexer.INDEX:
    case SparqlQueryLexer.LIMIT:
    case SparqlQueryLexer.MINUS:
    case SparqlQueryLexer.NAMED:
    case SparqlQueryLexer.OFFSET:
    case SparqlQueryLexer.OPTIONAL:
    case SparqlQueryLexer.ORDER:
    case SparqlQueryLexer.PREFIX:
    case SparqlQueryLexer.REDUCED:
    case SparqlQueryLexer.SELECT:
    case SparqlQueryLexer.SERVICE:
    case SparqlQueryLexer.SHORTEST:
    case SparqlQueryLexer.SHOW:
    case SparqlQueryLexer.SILENT:
    case SparqlQueryLexer.SIMPLE:
    case SparqlQueryLexer.UNDEF:
    case SparqlQueryLexer.UNION:
    case SparqlQueryLexer.VALUES:
    case SparqlQueryLexer.WALKS:
    case SparqlQueryLexer.WHERE:
      return "keyword";
    case SparqlQueryLexer.ABS:
    case SparqlQueryLexer.AVG:
    case SparqlQueryLexer.BIND:
    case SparqlQueryLexer.BNODE:
    case SparqlQueryLexer.BOUND:
    case SparqlQueryLexer.CEIL:
    case SparqlQueryLexer.COALESCE:
    case SparqlQueryLexer.CONCAT:
    case SparqlQueryLexer.CONTAINS:
    case SparqlQueryLexer.COUNT:
    case SparqlQueryLexer.DATATYPE:
    case SparqlQueryLexer.DAY:
    case SparqlQueryLexer.ENCODE_FOR_URI:
    case SparqlQueryLexer.EXISTS:
    case SparqlQueryLexer.FLOOR:
    case SparqlQueryLexer.GROUP_CONCAT:
    case SparqlQueryLexer.HOURS:
    case SparqlQueryLexer.IF:
    case SparqlQueryLexer.IN:
    case SparqlQueryLexer.IRI:
    case SparqlQueryLexer.ISBLANK:
    case SparqlQueryLexer.ISIRI:
    case SparqlQueryLexer.ISLITERAL:
    case SparqlQueryLexer.ISNUMERIC:
    case SparqlQueryLexer.ISURI:
    case SparqlQueryLexer.LANG:
    case SparqlQueryLexer.LANGMATCHES:
    case SparqlQueryLexer.LCASE:
    case SparqlQueryLexer.MAX:
    case SparqlQueryLexer.MD5:
    case SparqlQueryLexer.MIN:
    case SparqlQueryLexer.MINUTES:
    case SparqlQueryLexer.MONTH:
    case SparqlQueryLexer.NOT:
    case SparqlQueryLexer.NOW:
    case SparqlQueryLexer.RAND:
    case SparqlQueryLexer.REGEX:
    case SparqlQueryLexer.REPLACE:
    case SparqlQueryLexer.ROUND:
    case SparqlQueryLexer.SAMETERM:
    case SparqlQueryLexer.SAMPLE:
    case SparqlQueryLexer.SECONDS:
    case SparqlQueryLexer.SEPARATOR:
    case SparqlQueryLexer.SHA1:
    case SparqlQueryLexer.SHA256:
    case SparqlQueryLexer.SHA384:
    case SparqlQueryLexer.SHA512:
    case SparqlQueryLexer.STR:
    case SparqlQueryLexer.STRAFTER:
    case SparqlQueryLexer.STRBEFORE:
    case SparqlQueryLexer.STRDT:
    case SparqlQueryLexer.STRENDS:
    case SparqlQueryLexer.STRLANG:
    case SparqlQueryLexer.STRLEN:
    case SparqlQueryLexer.STRSTARTS:
    case SparqlQueryLexer.STRUUID:
    case SparqlQueryLexer.SUBSTR:
    case SparqlQueryLexer.SUM:
    case SparqlQueryLexer.TIMEZONE:
    case SparqlQueryLexer.TZ:
    case SparqlQueryLexer.UCASE:
    case SparqlQueryLexer.URI:
    case SparqlQueryLexer.UUID:
    case SparqlQueryLexer.YEAR:
      return "function";
    case SparqlQueryLexer.ALPHANUMERIC_IDENTIFIER: // procedures
      return "function";
    default:
      return "";
  }
};

export { GQLTokenToScopes, MQLTokenToScopes, SPARQLTokenToScopes };
